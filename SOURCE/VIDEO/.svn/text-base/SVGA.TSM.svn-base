;***********
;
;Librer¡a de funciones C para usar el modo de 640x400 256 colores.
;
;Se soportan dos tipos de VGA espec¡ficos:
;
;	Tseng ET4000 de Tseng Labs.
;	VGA's compatibles con la norma VESA.
;
;
;(C) COPYRIGHT 1993 Eugenio Luis Barahona Marciel
;
;***********

		LOCALS	$$

BIOS		EQU	10H

;****
;
;Puertos del chip VGA.
;
;****

PEL_READ_ADDR	EQU	3C7H
PEL_WRITE_ADDR	EQU	3C8H
PEL_DATA	EQU	3C9H
GDC_INDEX	EQU	3CEH
ATC_INDEX	EQU	3C0H
TS_INDEX 	EQU	3C4H


		.286P

GRANABS_TEXT	SEGMENT	byte public 'CODE'

		ASSUME	CS:GRANABS_TEXT

;***********
;
;INICIALIZA ALGUNAS VARIABLES USADAS POR LA LIBRERIA.
;
;ENTRADAS:
;	NINGUNA.
;
;SALIDAS:
;	NINGUNA.
;
;***********

		PUBLIC	_Init_Svgalib

_Init_Svgalib	PROC	FAR
		PUSH	BP
		PUSH	DS
		PUSH	ES
		PUSHA
		MOV	AX,1130H
		MOV	BH,3
		INT	BIOS
		MOV	WORD PTR CS:[FONT8x8+2],ES
		MOV	WORD PTR CS:[FONT8x8],BP
		MOV	BH,2
		INT	BIOS
		MOV	WORD PTR CS:[FONT8x14+2],ES
		MOV	WORD PTR CS:[FONT8x14],BP
		MOV	BH,6
		INT	BIOS
		MOV	WORD PTR CS:[FONT8x16+2],ES
		MOV	WORD PTR CS:[FONT8x16],BP
		POPA
		POP	ES
		POP	DS
		POP	BP
		RET
_Init_Svgalib	ENDP

ALTO_CHR    	DW	?
FONT8x8		DD	?
FONT8x14    	DD	?
FONT8x16    	DD	?
ACTUAL_FONT 	DD	?

;***********
;
;ALMCACENA EN UN BUFFER UNA SERIE DE COLORES DE LA PALETA.
;
;ENTRADAS:
;	[DEST]=BUFFER DONDE ALMACENAR LOS COLORES
;	[START_COLOR]=COLOR INICIAL
;	[NUM_COLOR]=NUMERO DE COLORES A DEVOLVER
;
;***********

DEST		EQU	BP+6
START_COLOR	EQU	BP+10
NUM_COLOR	EQU	BP+12

		PUBLIC	_Get_Colors

_Get_Colors	PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	ES
		LES	DI,DWORD PTR [DEST]
		MOV	DX,PEL_READ_ADDR
		MOV	AX,WORD PTR [START_COLOR]
		OUT	DX,AL
		MOV	DX,PEL_DATA
		MOV	AX,WORD PTR [NUM_COLOR]
		MOV	CX,AX
		ADD	AX,AX
		ADD	CX,AX
		CLD
		REP	INSB
		POP	ES
		POPA
		POP	BP
		RET
_Get_Colors	ENDP

;***********
;
;ACTUALIZA LA PALETA DE COLORES CON EL CONTENIDO DE UN BUFFER.
;
;ENTRADAS:
;	[SOURCE]=APUNTA AL BUFFER CON LA PALETA A ACTIVAR
;	[START_COLOR]=COLOR INICIAL
;	[NUM_COLOR]=NUMERO DE COLORES A MODIFICAR
;
;***********

SOURCE		EQU	BP+6

		PUBLIC	_Set_Colors

_Set_Colors	PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	DS
		LDS	SI,DWORD PTR [SOURCE]
		MOV	DX,PEL_WRITE_ADDR
		MOV	AX,WORD PTR [START_COLOR]
		OUT	DX,AL
		MOV	DX,PEL_DATA
		MOV	AX,WORD PTR [NUM_COLOR]
		MOV	CX,AX
		ADD	AX,AX
		ADD	CX,AX
		CLD
		REP	OUTSB
		POP	DS
		POPA
		POP	BP
		RET
_Set_Colors	ENDP

;***********
;
;ESPERA UN RETORNO DE CUADRO.
;
;ENTRADAS:
;	NINGUNA.
;
;SALIDAS:
;	RETORNA CUANDO SE PRODUCE EL RETORNO DE CUADRO.
;
;***********

		PUBLIC	_Wait_Vbl

_Wait_Vbl   	PROC	FAR
		PUSH	AX
		PUSH	DX
		MOV	DX,WORD PTR CS:[STATUS1]
$$WAIT:		IN	AL,DX
		TEST	AL,8
		JZ	$$WAIT
		POP	DX
		POP	AX
		RET
_Wait_Vbl   	ENDP

;***********
;
;PINTA UN PIXEL EN UNAS COORDENADAS DE LA PANTALLA.
;
;ENTRADAS:
;	XPOS=COORDENADA X
;	YPOS=COORDENADA Y
;
;SALIDAS:
;	PINTA EL PIXEL EN LA PANTALLA
;
;***********

XPOS		EQU	BP+6
YPOS		EQU	BP+8

		PUBLIC	_Put_Pixel

_Put_Pixel  	PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	DS
		PUSH	ES
		MOV	CX,WORD PTR [YPOS]
		MOV	DX,WORD PTR [XPOS]
		CALL	SCREEN_OFFSET
		MOV	DX,TS_INDEX
		MOV	AL,2
		OUT	DX,AX	;SELECCIONA MAPA ESCRITURA
		MOV	AL,BYTE PTR CS:[ACTUAL_COLOR]
		STOSB
		POP	ES
		POP	DS
		POPA
		POP	BP
		RET
_Put_Pixel  	ENDP

;***********
;
;SELECCIONA EL COLOR CON EL CUAL SE VAN A PINTAR PIXELS Y LINEAS.
;
;ENTRADAS:
;	COLOR=NUEVO COLOR A USAR
;
;SALIDAS:
;	ACTUALIZA LA VARIABLE ACTUAL_COLOR
;
;***********

		PUBLIC	_Set_Actual_Color

COLOR		EQU	BP+6

_Set_Actual_Color PROC	FAR
		PUSH	BP
		MOV	BP,SP
		MOV	AX,WORD PTR [COLOR]
		MOV	WORD PTR CS:[ACTUAL_COLOR],AX
		POP	BP
		RET
_Set_Actual_Color ENDP

;***********
;
;IMPRIME UNA CADENA DE CARACTERES.
;
;ENTRADAS:
;	XPOS=COORDENADA X
;	YPOS=COORDENADA Y
;	SOURCE=DIRECCION DE LA CADENA DE TEXTO
;	TIPO=TIPO DE CARACTERES A USAR
;
;SALIDAS:
;	PINTA LA CADENA DE TEXTO EN PANTALLA
;
;***********

XPOS		EQU	BP+6
YPOS		EQU	BP+8
SOURCE		EQU	BP+10
TIPO		EQU	BP+14

		PUBLIC	_Draw_String

_Draw_String	PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSH	DS
		PUSH	ES
		PUSHA
		MOV	SI,WORD PTR [TIPO]
		CMP	SI,3
		JC	$$TIPO_OK
		XOR	SI,SI
		MOV	WORD PTR [TIPO],SI
$$TIPO_OK:	PUSH	SI
		ADD	SI,SI
		ADD	SI,SI
		ADD	SI,OFFSET FONT8x8
		LDS	SI,DWORD PTR CS:[SI]
		MOV	WORD PTR CS:[ACTUAL_FONT+2],DS
		MOV	WORD PTR CS:[ACTUAL_FONT],SI
		MOV	DX,8
		POP	SI
		AND	SI,SI
		JZ	$$OK0
		MOV	DL,14
		CMP	SI,1
		JZ	$$OK0
		MOV	DL,16
$$OK0:		MOV	WORD PTR CS:[ALTO_CHR],DX
;
;- SELECCIONAR MODO 0 DE ESCRITURA E INDEXAR SELECCION MAPA DE ESCRITURA.
;
		MOV	DX,GDC_INDEX
		MOV	AX,4005H
		OUT	DX,AX		;MODO 0 ESCRITURA
		MOV	DX,TS_INDEX
		MOV	AL,2
		OUT	DX,AL
		INC	DX
;
;- HALLAR LA DIRECCION DE PANTALLA.
;
		PUSH	DX
		MOV	CX,WORD PTR [YPOS]
		MOV	DX,WORD PTR [XPOS]
		CALL	SCREEN_OFFSET
		POP	DX
		MOV	BX,AX
		LDS	SI,DWORD PTR [SOURCE]	;APUNTAMOS AL TEXTO
		CLD
$$LOOP0:	LODSB
		AND	AL,AL
		JZ	$$END
		PUSH	DS
		PUSH	SI
		CALL	LOOK_CHR
		CALL	PRINT_CHR
		POP	SI
		POP	DS
		JMP	SHORT $$LOOP0
$$END:		POPA
		POP	ES
		POP	DS
		POP	BP
		RET
_Draw_String	ENDP

;***********
;
;IMPRIME UN CARACTER EN PANTALLA
;
;ENTRADAS:
;	DS:SI=DEFINICION DEL CARACTER
;	ES:DI=DIRECCION DE PANTALLA
;	BX=MASCARA DE ESCRITURA
;	DX=PUERTO SELECCION MAPA DE ESCRITURA
;
;SALIDAS:
;	ES:DI=DIRECCION PANTALLA PARA EL SIGUIENTE CARACTER
;	BX y DX IGUAL QUE A LA ENTRADA
;
;***********

PRINT_CHR	PROC	NEAR
		PUSH	DI
		PUSH	BX
		CMP	BL,11H
		JNZ	$$HALF
;
;- LA DIRECCION SE AJUSTA A UN BLOQUE DE 4 PIXELS.
;
		MOV	BX,OFFSET WRITE_CONV
		MOV	CX,WORD PTR CS:[ALTO_CHR]
$$LOOP0:	LODSB		;AL=BYTE DEL CARACTER
		MOV	AH,AL
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		XLAT	CS:WRITE_CONV
		OUT	DX,AL
		PUSH	AX
		MOV	AX,WORD PTR CS:[ACTUAL_COLOR]
		STOSB
		POP	AX
		MOV	AL,AH
		AND	AL,0FH
		XLAT	CS:WRITE_CONV
		OUT	DX,AL
		PUSH	AX
		MOV	AX,WORD PTR CS:[ACTUAL_COLOR]
		STOSB
		POP	AX
		ADD	DI,158
		LOOP	$$LOOP0
		POP	BX
		POP	DI
		ADD	DI,2
		RET
;
;- LA DIRECCION NO SE AJUSTA A BLOQUES DE 4 PIXELS.
;
$$HALF:		MOV	CX,WORD PTR CS:[ALTO_CHR]
$$LOOP1:	PUSH	CX
		PUSH	DI
		LODSB		;AL=BYTE DEL CARACTER
		XOR	BH,BH
		MOV	CL,8
$$LOOP2:	ROL	AL,1
		JC	$$PUT_PIXEL
		ROL	BL,1
		JNC	$$OK0
		PUSH	AX
		MOV	AL,BH
		OUT	DX,AL
		MOV	AX,WORD PTR CS:[ACTUAL_COLOR]
		STOSB
		POP	AX
		XOR	BH,BH
$$OK0:		LOOP	$$LOOP2
		MOV	AL,BH
		OUT	DX,AL
		MOV	AX,WORD PTR CS:[ACTUAL_COLOR]
		STOSB
		JMP	SHORT $$YLOOP
$$PUT_PIXEL:	OR	BH,BL
		ROL	BL,1
		JNC	$$OK1
		PUSH	AX
		MOV	AL,BH
		OUT	DX,AL
		MOV	AX,WORD PTR CS:[ACTUAL_COLOR]
		STOSB
		POP	AX
		XOR	BH,BH
$$OK1:		LOOP	$$LOOP2
		MOV	AL,BH
		OUT	DX,AL
		MOV	AX,WORD PTR CS:[ACTUAL_COLOR]
		STOSB
$$YLOOP:	POP	DI
		ADD	DI,160
		POP	CX
		LOOP	$$LOOP1
		POP	BX
		POP	DI
		ADD	DI,2
		RET
PRINT_CHR	ENDP

WRITE_CONV	DB	0000B	;0000B
		DB	1000B	;0001B
		DB	0100B	;0010B
		DB	1100B	;0011B
		DB	0010B	;0100B
		DB	1010B	;0101B
		DB	0110B	;0110B
		DB	1110B	;0111B
		DB	0001B	;1000B
		DB	1001B	;1001B
		DB	0101B	;1010B
		DB	1101B	;1011B
		DB	0011B	;1100B
		DB	1011B	;1101B
		DB	0111B	;1110B
		DB	1111B	;1111B

;***********
;
;BUSCA LA DIRECCION DE UN CARACTER ASCII
;
;ENTRADAS:
;	AL=CARACTER ASCII
;	TIPO=JUEGO DE CARACTERES A USAR
;
;SALIDAS:
;	DS:SI=CARACTER BUSCADO
;
;***********

LOOK_CHR	PROC	NEAR
		PUSH	DX
		LDS	SI,DWORD PTR CS:[ACTUAL_FONT]
		MOV	DX,WORD PTR CS:[ALTO_CHR]
		XOR	AH,AH
		MUL	DX
		ADD	SI,AX
		POP	DX
		RET
LOOK_CHR	ENDP

;***********
;
;IMPRIME UN MAPA DE BITS ALMACENADO EN MEMORIA.
;
;ENTRADAS:
;	XPOS=COORDENADA X
;	YPOS=COORDENADA Y
;	ALTO=ALTURA EN PIXELS
;	ANCHO=ANCHURA EN PIXELS
;	SOURCE=DIRECCION DEL BITMAP
;
;SALIDAS:
;	IMPRIME EL BITMAP EN PANTALLA
;
;***********

XPOS		EQU	BP+6
YPOS		EQU	BP+8
ALTO		EQU	BP+10
ANCHO		EQU	BP+12
SOURCE		EQU	BP+14

		PUBLIC	_Put_Bitmap

_Put_Bitmap	PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	DS
		PUSH	ES
		MOV	DX,GDC_INDEX
		MOV	AL,5
		OUT	DX,AL
		INC	DL
		IN	AL,DX
		AND	AL,11111100B
		OUT	DX,AL		;MODO 0 DE ESCRITURA
		MOV	CX,WORD PTR [YPOS]
		MOV	DX,WORD PTR [XPOS]
		CALL	SCREEN_OFFSET
		MOV	DX,TS_INDEX
		MOV	AL,2
		OUT	DX,AL
		INC	DL
		LDS	SI,DWORD PTR [SOURCE]
		CLD
		MOV	BX,160
		MOV	CX,WORD PTR SS:[ALTO]
$$LOOP0:	PUSH	CX
		PUSH	DI
		MOV	CX,WORD PTR SS:[ANCHO]
$$LOOP1:	MOV	AL,AH
		OUT	DX,AL
		LODSB
		AND	AL,AL
		JZ	$$VACIO
		MOV	BYTE PTR ES:[DI],AL
$$VACIO:	ROL	AH,1
		ADC	DI,0
		LOOP	$$LOOP1
		POP	DI
		ADD	DI,BX
		POP	CX
		LOOP	$$LOOP0
		POP	ES
		POP	DS
		POPA
		POP	BP
		RET
_Put_Bitmap	ENDP

;***********
;
;ALMACENA EN MEMORIA CONVENCIONAL UN BITMAP QUE ESTA EN PANTALLA
;
;ENTRADAS:
;	XPOS=COORDENADA X
;	YPOS=COORDENADA Y
;	ALTO=ALTURA EN PIXELS
;	ANCHO=ANCHURA EN PIXELS
;	DEST=DIRECCION DE MEMORIA CONVENCIONAL
;
;SALIDAS:
;	COPIA EL BITMAP A MEMORIA CONVENCIONAL
;
;***********

XPOS		EQU	BP+6
YPOS		EQU	BP+8
ALTO		EQU	BP+10
ANCHO		EQU	BP+12
DEST		EQU	BP+14

		PUBLIC	_Get_Bitmap

_Get_Bitmap	PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	DS
		PUSH	ES
		MOV	DX,GDC_INDEX
		MOV	AL,5
		OUT	DX,AL
		INC	DL
		IN	AL,DX
		AND	AL,11110100B
		OUT	DX,AL	;MODO 0 DE LECTURA
		DEC	DL
		MOV	AL,4
		OUT	DX,AL	;INDEXA SELECCION PLANO LECTURA
		INC	DL
		PUSH	DX
		MOV	CX,WORD PTR [YPOS]
		MOV	DX,WORD PTR [XPOS]
		PUSH	DX
		CALL	SCREEN_OFFSET
		MOV	AX,ES
		MOV	DS,AX
		MOV	SI,DI
		POP	AX
		AND	AX,11B		;AL=PLANO DE LECTURA
		POP	DX
		MOV	BX,160
		LES	DI,DWORD PTR SS:[DEST]
		CLD
		MOV	CX,WORD PTR SS:[ALTO]
$$LOOP0:	PUSH	CX
		PUSH	SI
		MOV	CX,WORD PTR SS:[ANCHO]
$$LOOP1:	OUT	DX,AL	;SELECCIONA PLANO LECTURA
		MOVSB
		INC	AL
		AND	AL,11B
		JZ	$$OK
		DEC	SI
$$OK:		LOOP	$$LOOP1
		POP	SI
		ADD	SI,BX
		POP	CX
		LOOP	$$LOOP0
		POP	ES
		POP	DS
		POPA
		POP	BP
		RET
_Get_Bitmap	ENDP

;***********
;
;COPIA UNA ZONA DE PANTALLA A OTRA USANDO EL MODO 1 DE ESCRITURA.
;
;ENTRADAS:
;	XPOS1=COORDENADA X DEL ORIGEN
;	YPOS1=COORDENADA Y DEL ORIGEN
;	XPOS2=COORDENADA X DEL DESTINO
;	YPOS2=COORDENADA Y DEL DESTINO
;	ALTO=ALTURA EN PIXELS DEL BLOQUE
;	ANCHO=ANCHURA EN PIXELS DEL BLOQUE
;
;SALIDAS:
;	COPIA EL BLOQUE ORIGEN AL BLOQUE DESTINO
;
;***********

XPOS1		EQU	BP+6
YPOS1		EQU	BP+8
XPOS2		EQU	BP+10
YPOS2		EQU	BP+12
ALTO		EQU	BP+14
ANCHO		EQU	BP+16

		PUBLIC	_Mode1_Copy_Screen_Block

_Mode1_Copy_Screen_Block PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	DS
		PUSH	ES
		MOV	DX,GDC_INDEX
		MOV	AL,5
		OUT	DX,AL
		INC	DL
		IN	AL,DX
		AND	AL,11111100B
		OR	AL,1
		OUT	DX,AL	;MODO 1 DE ESCRITURA
		MOV	DX,TS_INDEX
		MOV	AX,0F02H
		OUT	DX,AX
		MOV	CX,WORD PTR [YPOS1]
		MOV	DX,WORD PTR [XPOS1]
		CALL	SCREEN_OFFSET
		MOV	SI,DI
		MOV	CX,WORD PTR [YPOS2]
		MOV	DX,WORD PTR [XPOS2]
		CALL	SCREEN_OFFSET
		MOV	AX,ES
		MOV	DS,AX
		CLD
		MOV	BX,160
		MOV	CX,WORD PTR [ALTO]
$$LOOP0:	PUSH	CX
		PUSH	SI
		PUSH	DI
		MOV	CX,WORD PTR [ANCHO]
		SHR	CX,1
		SHR	CX,1	;/4
		REP	MOVSB
		POP	DI
		POP	SI
		ADD	SI,BX
		ADD	DI,BX
		POP	CX
		LOOP	$$LOOP0
		POP	ES
		POP	DS
		POPA
		POP	BP
		RET
_Mode1_Copy_Screen_Block ENDP

;***********
;
;COPIA UNA ZONA DE PANTALLA A OTRA USANDO EL MODO 0.
;
;ENTRADAS:
;	XPOS1=COORDENADA X DEL ORIGEN
;	YPOS1=COORDENADA Y DEL ORIGEN
;	XPOS2=COORDENADA X DEL DESTINO
;	YPOS2=COORDENADA Y DEL DESTINO
;	ALTO=ALTURA EN PIXELS DEL BLOQUE
;	ANCHO=ANCHURA EN PIXELS DEL BLOQUE
;
;SALIDAS:
;	COPIA EL BLOQUE ORIGEN AL BLOQUE DESTINO
;
;***********

XPOS1		EQU	BP+6
YPOS1		EQU	BP+8
XPOS2		EQU	BP+10
YPOS2		EQU	BP+12
ALTO		EQU	BP+14
ANCHO		EQU	BP+16

		PUBLIC	_Mode0_Copy_Screen_Block

_Mode0_Copy_Screen_Block PROC	FAR
		PUSH	BP
		MOV	BP,SP
		PUSHA
		PUSH	DS
		PUSH	ES
		MOV	DX,GDC_INDEX
		MOV	AL,5
		OUT	DX,AL
		INC	DL
		IN	AL,DX
		AND	AL,11110100B
		OUT	DX,AL	;MODO 0 DE LECTURA Y ESCRITURA
		DEC	DL
		MOV	AL,4
		OUT	DX,AL	;INDEXA SELECCION MAPA LECTURA
		MOV	DX,TS_INDEX
		MOV	AL,2
		OUT	DX,AL	;INDEXA SELECCION MAPA ESCRITURA
		MOV	CX,WORD PTR [YPOS1]
		MOV	DX,WORD PTR [XPOS1]
		CALL	SCREEN_OFFSET
		MOV	SI,DI
		MOV	CX,WORD PTR [YPOS2]
		MOV	DX,WORD PTR [XPOS2]
		CALL	SCREEN_OFFSET
		MOV	CX,ES
		MOV	DS,CX
		MOV	DX,WORD PTR [XPOS1]
		AND	DX,11B
		MOV	AL,DL
		MOV	DH,3
		MOV	BX,160
		CLD
		MOV	CX,WORD PTR [ALTO]
$$LOOP0:	PUSH	CX
		PUSH	SI
		PUSH	DI
		MOV	CX,WORD PTR [ANCHO]
$$LOOP1:	MOV	DL,0CFH
		OUT	DX,AL	;SELECCIONA PLANO LECTURA
		MOV	DL,0C5H
		XCHG	AL,AH
		OUT	DX,AL	;SELECCIONA PLANO ESCRITURA
		XCHG	AL,AH
		MOVSB
		ROL	AH,1
		JC	$$OK0
		DEC	DI
$$OK0:		INC	AL
		AND	AL,11B
		JZ	$$OK1
		DEC	SI
$$OK1:		LOOP	$$LOOP1
		POP	DI
		POP	SI
		ADD	SI,BX
		ADD	DI,BX
		POP	CX
		LOOP	$$LOOP0
		POP	ES
		POP	DS
		POPA
		POP	BP
		RET
_Mode0_Copy_Screen_Block ENDP

;***********
;
;DEVUELVE LA DIRECCION DE PANTALLA DE UNAS DETERMINADAS COORDENADAS.
;
;ENTRADAS:
;	CX=COORDENADA Y
;	DX=COORDENADA X
;
;SALIDAS:
;	ES:DI=DIRECCION PANTALLA
;	AH=MAPA ESCRITURA
;
;***********

SCREEN_OFFSET	PROC	NEAR
;***********
;
;Inicializa el modo de 640x400 con 256 colores en ET4000.
;
;Entradas:	ninguna.
;
;Salidas:	ninguna.
;
;***********

		PUBLIC	_Set_Et4000_Mode

_Set_Et4000_Mode PROC	FAR
		PUSH	DS
		MOV	AX,CS
		MOV	DS,AX
		MOV	AX,13H
		INT	BIOS		;Activa 320x200 con 256 colores
		CLD
		CLI
		PUSH	ES
		MOV	AX,40H
		MOV	ES,AX
		MOV	BX,WORD PTR ES:[63H]
		MOV	DX,3DAH
		CMP	BL,0D4H
		JZ	$$STATUS_OK
		MOV	DL,0BAH
$$STATUS_OK:	MOV	WORD PTR CS:[STATUS1],DX
		MOV	WORD PTR CS:[CRTC_INDEX],BX
$$WAIT_VBL:	IN	AL,DX
		TEST	AL,8
		JZ	$$WAIT_VBL
		MOV	DX,TS_INDEX
		MOV	AL,1
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,11111100B
		OUT	DX,AL
		MOV	DX,WORD PTR CS:[CRTC_INDEX]
		MOV	AL,11H
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		PUSH	AX
		AND	AL,7FH
		OUT	DX,AL		;Habilita escritura en el CRTC.
		DEC	DX
		MOV	SI,OFFSET CRTC_REGS
		MOV	CX,WORD PTR [SI]
		ADD	SI,2
		CLD
		REP	OUTSW
		MOV	AL,11H
		OUT	DX,AL
		INC	DX
		POP	AX
		OUT	DX,AL
		MOV	DX,TS_INDEX
		MOV	AL,1
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,11110011B
		OUT	DX,AL
		MOV	DX,WORD PTR CS:[STATUS1]
		PUSH	DX
		IN	AL,DX
		MOV	DX,ATC_INDEX
		MOV	AL,10H
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,10111111B
		DEC	DX
		OUT	DX,AL
		POP	DX
		IN	AL,DX
		MOV	DX,ATC_INDEX
		MOV	AL,20H
		OUT	DX,AL
		MOV	DX,TS_INDEX
		MOV	AL,4
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0F7H
		OR	AL,4
		OUT	DX,AL
		MOV	DX,GDC_INDEX
		MOV	AL,5
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0EFH
		OUT	DX,AL
		DEC	DX
		MOV	AL,6
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0FDH
		OUT	DX,AL
		MOV	DX,TS_INDEX
		MOV	AL,1
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		OR	AL,11B
		OUT	DX,AL
		MOV	AX,0A000H
		MOV	ES,AX
		XOR	DI,DI
		MOV	AX,DI
		MOV	CX,65535
		REP	STOSB
		POP	ES
		POP	DS
		STI
		RET

STATUS1		DW	?
CRTC_INDEX	DW	?

;
;- Tabla para programar el CRTC.
;
CRTC_REGS	DW	24		;N£mero de registros a programar
		DW	5F00H
		DW	4F01H
		DW	5002H
		DW	8203H
		DW	5404H
		DW	8005H
		DW	0BF06H
		DW	1F07H
		DW	008H
		DW	4009H
		DW	0AH
		DW	0BH
		DW	0CH
		DW	0DH
		DW	0EH
		DW	0FH
		DW	9C10H
		DW	8F12H
		DW	5013H
		DW	2014H
		DW	9615H
		DW	0B916H
		DW	0EB17H
		DW	0FF18H
_Set_Et4000_Mode ENDP

;***********
;
;Inicializa el modo de 640x400 con 256 colores para VGA VESA.
;
;Entradas:	ninguna.
;
;Salidas:	AX=0  -> Se activo el modo correctamente.
;		AX<>0 -> No se activo el modo correctamente.
;
;***********

		PUBLIC	_SET_VESA_MODE

_SET_VESA_MODE	PROC	FAR
		PUSH	DS
		MOV	AX,CS
		MOV	DS,AX
		MOV	AX,4F02H
		MOV	BX,100H
		INT	BIOS		;Activa 640x400 con 256 colores VESA
		CMP	AX,4FH
		JZ	$$OK
		MOV	AX,0FFFFH
		RET
$$OK:		CLD
		CLI
		PUSH	ES
		MOV	AX,40H
		MOV	ES,AX
		MOV	BX,WORD PTR ES:[63H]
		MOV	DX,3DAH
		CMP	BL,0D4H
		JZ	$$STATUS_OK
		MOV	DL,0BAH
$$STATUS_OK:	MOV	WORD PTR CS:[STATUS1],DX
		MOV	WORD PTR CS:[CRTC_INDEX],BX
$$WAIT_VBL:	IN	AL,DX
		TEST	AL,8
		JZ	$$WAIT_VBL
		MOV	DX,TS_INDEX
		MOV	AL,4
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0F7H
		OR	AL,4
		OUT	DX,AL
		MOV	DX,GDC_INDEX
		MOV	AL,5
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0EFH
		OUT	DX,AL
		DEC	DX
		MOV	AL,6
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0FDH
		OUT	DX,AL
		MOV	DX,WORD PTR CS:[CRTC_INDEX]
		MOV	AL,14H
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		AND	AL,0BFH
		OUT	DX,AL
		DEC	DX
		MOV	AL,17H
		OUT	DX,AL
		INC	DX
		IN	AL,DX
		OR	AL,40H
		OUT	DX,AL
		MOV	AX,0A000H
		MOV	ES,AX
		XOR	DI,DI
		MOV	AX,DI
		MOV	CX,65535
		REP	STOSB
		POP	ES
		POP	DS
		STI
		RET
_SET_VESA_MODE	ENDP

ACTUAL_COLOR	DW	?	;COLOR SELECCIONADO PARA ESCRITURA

GRANABS_TEXT	ENDS

		END

